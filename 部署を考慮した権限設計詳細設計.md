# 部署を考慮した権限設計 詳細設計書

## 1. 概要

本設計は、部署を考慮した権限管理システムの実装詳細を定義します。
`department_scope`カラムによるシンプルなスコープ管理と、`PermissionDetail_Department`中間テーブルによる
複数部門への正規化対応を統合した形で実装を行います。

## 2. 前提条件

### 2.1. 技術スタック
- Java: 21
- Kotlin: 2.1.0
- Spring Boot: 3.2.2
- Spring Framework: 6.2.x
- ORM: jOOQ 3.19.1
- DB: MySQL 8.0
- テスト: Kotest 5.9.0, Mockk 1.13.9
- Flyway: 9.22.3

### 2.2. プロジェクト構成
```
src/
└── main/
    └── kotlin/
        └── com/example/project/
            └── organization/
                ├── domain/
                │   ├── model/
                │   │   ├── Permission.kt
                │   │   ├── PermissionScope.kt
                │   │   └── vo/
                │   │       └── DepartmentScope.kt
                │   ├── repository/
                │   │   ├── PermissionRepository.kt
                │   │   └── PermissionDepartmentRepository.kt
                │   └── service/
                │       └── PermissionDomainService.kt
                ├── application/
                │   ├── service/
                │   │   └── PermissionService.kt
                │   ├── usecase/
                │   │   ├── CreatePermissionUseCase.kt
                │   │   └── UpdatePermissionUseCase.kt
                │   └── dto/
                │       ├── PermissionDto.kt
                │       └── DepartmentScopeDto.kt
                ├── infrastructure/
                │   └── repository/
                │       ├── PermissionRepositoryImpl.kt
                │       └── PermissionDepartmentRepositoryImpl.kt
                └── presentation/
                    ├── controller/
                    │   └── PermissionController.kt
                    └── request/
                        └── CreatePermissionRequest.kt
```

### 2.3. データベース設定
- Docker コンテナ上で動作
- プロダクション用DB:
  - データベース名: compliance_management_system
  - ユーザー名: compliance_user
  - パスワード: compliance_pass
  - 接続URL: jdbc:mysql://localhost:3307/compliance_management_system
- テスト用DB:
  - データベース名: 
    - code_master_db_test
    - organization_db_test
    - risk_db_test
    - framework_db_test
    - audit_db_test
    - document_db_test
    - training_db_test
  - ユーザー名: root
  - パスワード: root
  - 接続URL: jdbc:mysql://localhost:3307/{database_name}
- 文字コード: utf8mb4
- 照合順序: utf8mb4_unicode_ci

### 2.4. jOOQ設定
```kotlin
jooq {
    version.set("3.19.1")
    configurations {
        create("main") {
            jooqConfiguration.apply {
                jdbc.apply {
                    driver = "com.mysql.cj.jdbc.Driver"
                    url = "jdbc:mysql://${project.property("dbHost")}:${project.property("dbPort")}/${project.property("dbCodeMasterTest")}"
                    user = project.property("dbUsername").toString()
                    password = project.property("dbPassword").toString()
                }
                generator.apply {
                    name = "org.jooq.codegen.KotlinGenerator"
                    database.apply {
                        name = "org.jooq.meta.mysql.MySQLDatabase"
                        inputSchema = "code_master_db_test"
                        includes = ".*"
                        excludes = ""
                        forcedTypes.addAll(
                            listOf(
                                org.jooq.meta.jaxb.ForcedType()
                                    .withName("BOOLEAN")
                                    .withIncludeTypes("TINYINT\\(1\\)")
                            )
                        )
                    }
                    generate.apply {
                        isDeprecated = false
                        isRecords = true
                        isImmutablePojos = true
                        isFluentSetters = true
                        isPojosEqualsAndHashCode = true
                        isJavaTimeTypes = true
                        isKotlinNotNullRecordAttributes = true
                        isKotlinNotNullPojoAttributes = true
                    }
                    target.apply {
                        packageName = "com.example.project.jooq"
                        directory = "build/generated-src/jooq/main"
                    }
                    strategy.name = "org.jooq.codegen.DefaultGeneratorStrategy"
                }
            }
        }
    }
}
```

### 2.5. ユニットテスト設計

#### 2.5.1 PermissionRepositoryImplTest

```kotlin
// パス: src/test/kotlin/com/example/project/organization/infrastructure/repository/PermissionRepositoryImplTest.kt

class PermissionRepositoryImplTest {
    
    // 1. 部門スコープ別の権限検索テスト
    @Test
    fun testFindByUserIdWithDepartmentScope() {
        // ANY_DEPT: 全部門に対する権限が取得できること
        // OWN_DEPT: 自部門のみの権限が取得できること
        // SPECIFIC: 特定部門の権限のみ取得できること
    }

    // 2. 部門スコープ保存テスト
    @Test
    fun testSaveWithDepartmentScope() {
        // ANY_DEPT での保存
        // OWN_DEPT での保存
        // SPECIFIC での保存（複数部門）
    }

    // 3. 部門スコープ更新テスト
    @Test
    fun testUpdateDepartmentScope() {
        // ANY_DEPT → SPECIFIC への変更
        // SPECIFIC → OWN_DEPT への変更
        // OWN_DEPT → ANY_DEPT への変更
    }

    // 4. 部門スコープ削除テスト
    @Test
    fun testDeleteWithDepartmentScope() {
        // SPECIFIC スコープの権限を削除した際に、中間テーブルのレコードも削除されること
    }
}

#### 2.5.2 PermissionServiceTest

```kotlin
// パス: src/test/kotlin/com/example/project/organization/application/service/PermissionServiceTest.kt

class PermissionServiceTest {
    
    // 1. 権限チェックテスト
    @Test
    fun testHasPermission() {
        // ANY_DEPT: 全部門へのアクセスが許可されること
        // OWN_DEPT: 自部門のみアクセス可能なこと
        // SPECIFIC: 特定部門のみアクセス可能なこと
    }

    // 2. 部門階層を考慮した権限チェックテスト
    @Test
    fun testHasPermissionWithDepartmentHierarchy() {
        // OWN_DEPT で下位部門へのアクセスが可能なこと
        // OWN_DEPT で上位部門へのアクセスが不可なこと
    }

    // 3. 権限付与テスト
    @Test
    fun testGrantPermission() {
        // ANY_DEPT での権限付与
        // OWN_DEPT での権限付与
        // SPECIFIC での権限付与（複数部門）
    }

    // 4. 権限剥奪テスト
    @Test
    fun testRevokePermission() {
        // 特定ユーザの特定権限を剥奪
        // 特定部門に対する権限のみを剥奪
    }
}
```

#### 2.5.3 テストデータ

テストデータは以下のパスに配置：
- `src/test/resources/db/testdata/organization_db/V1.9.9__insert_test_permission_data.sql`

```sql
-- テストユーザ
INSERT INTO User (user_id, department_id, username, email, password_hash, role_code)
VALUES 
('TEST_USER_1', 'DEPT_A', 'test_user_1', 'test1@example.com', 'hash', 'ROLE_USER'),
('TEST_USER_2', 'DEPT_B', 'test_user_2', 'test2@example.com', 'hash', 'ROLE_USER');

-- テスト部門
INSERT INTO Department (department_id, organization_id, parent_id, name, department_code)
VALUES
('DEPT_A', 'ORG_1', NULL, 'Department A', 'DEPT_A'),
('DEPT_B', 'ORG_1', NULL, 'Department B', 'DEPT_B'),
('DEPT_A_1', 'ORG_1', 'DEPT_A', 'Department A-1', 'DEPT_A_1');

-- テスト権限
INSERT INTO PermissionDetail (permission_id, user_id, permission_type, target_id, access_level, department_scope)
VALUES
('PERM_1', 'TEST_USER_1', 'DOCUMENT', NULL, 'READ', 'ANY_DEPT'),
('PERM_2', 'TEST_USER_1', 'DOCUMENT', NULL, 'WRITE', 'OWN_DEPT'),
('PERM_3', 'TEST_USER_2', 'DOCUMENT', NULL, 'READ', 'SPECIFIC');

-- テスト部門権限
INSERT INTO PermissionDetail_Department (permission_id, department_id)
VALUES
('PERM_3', 'DEPT_A'),
('PERM_3', 'DEPT_B');
```

## 3. 実装詳細

### 3.1. ドメインモデル

#### 3.1.1. DepartmentScope (Value Object)
ファイルパス: `src/main/kotlin/com/example/project/permission/domain/model/vo/DepartmentScope.kt`

```kotlin
package com.example.project.permission.domain.model.vo

enum class DepartmentScope(val value: String) {
    ANY_DEPT("ANY_DEPT"),
    OWN_DEPT("OWN_DEPT"),
    SPECIFIC("SPECIFIC");

    companion object {
        fun fromValue(value: String): DepartmentScope {
            return if (value.startsWith("DEPT_")) {
                SPECIFIC
            } else {
                values().find { it.value == value }
                    ?: throw IllegalArgumentException("Invalid department scope: $value")
            }
        }

        fun isDepartmentCode(value: String): Boolean = value.startsWith("DEPT_")
    }
}
```

#### 3.1.2. Permission (Entity)
ファイルパス: `src/main/kotlin/com/example/project/permission/domain/model/Permission.kt`

```kotlin
package com.example.project.permission.domain.model

import com.example.project.permission.domain.model.vo.DepartmentScope
import java.time.LocalDateTime

data class Permission(
    val permissionDetailId: Long,
    val permissionId: String,
    val userId: String,
    val permissionType: String,
    val targetId: String?,
    val accessLevel: String,
    val departmentScope: DepartmentScope,
    val specificDepartments: List<String> = emptyList(),
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
) {
    fun canAccess(targetDepartmentId: String, userDepartmentId: String): Boolean {
        return when (departmentScope) {
            DepartmentScope.ANY_DEPT -> true
            DepartmentScope.OWN_DEPT -> isSameOrSubDepartment(userDepartmentId, targetDepartmentId)
            DepartmentScope.SPECIFIC -> {
                if (DepartmentScope.isDepartmentCode(departmentScope.value)) {
                    departmentScope.value == targetDepartmentId
                } else {
                    specificDepartments.contains(targetDepartmentId)
                }
            }
        }
    }

    private fun isSameOrSubDepartment(userDepartmentId: String, targetDepartmentId: String): Boolean {
        // TODO: 組織階層チェックロジックの実装
        // 現時点では単純な一致チェックのみ
        return userDepartmentId == targetDepartmentId
    }
}
```

### 3.2. リポジトリ

#### 3.2.1. PermissionRepository
ファイルパス: `src/main/kotlin/com/example/project/permission/domain/repository/PermissionRepository.kt`

```kotlin
package com.example.project.permission.domain.repository

import com.example.project.permission.domain.model.Permission

interface PermissionRepository {
    fun findById(permissionDetailId: Long): Permission?
    fun findByUserId(userId: String): List<Permission>
    fun save(permission: Permission): Permission
    fun update(permission: Permission): Permission
    fun delete(permissionDetailId: Long)
}
```

#### 3.2.2. PermissionDepartmentRepository
ファイルパス: `src/main/kotlin/com/example/project/permission/domain/repository/PermissionDepartmentRepository.kt`

```kotlin
package com.example.project.permission.domain.repository

interface PermissionDepartmentRepository {
    fun findByPermissionDetailId(permissionDetailId: Long): List<String>
    fun save(permissionDetailId: Long, departmentIds: List<String>)
    fun delete(permissionDetailId: Long)
}
```

### 3.3. アプリケーションサービス

#### 3.3.1. PermissionService
ファイルパス: `src/main/kotlin/com/example/project/permission/application/service/PermissionService.kt`

```kotlin
package com.example.project.permission.application.service

import com.example.project.permission.domain.model.Permission
import com.example.project.permission.domain.model.vo.DepartmentScope
import com.example.project.permission.domain.repository.PermissionRepository
import com.example.project.permission.domain.repository.PermissionDepartmentRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class PermissionService(
    private val permissionRepository: PermissionRepository,
    private val permissionDepartmentRepository: PermissionDepartmentRepository
) {
    @Transactional(readOnly = true)
    fun findUserPermissions(userId: String): List<Permission> {
        return permissionRepository.findByUserId(userId).map { permission ->
            if (permission.departmentScope == DepartmentScope.SPECIFIC) {
                permission.copy(
                    specificDepartments = permissionDepartmentRepository
                        .findByPermissionDetailId(permission.permissionDetailId)
                )
            } else {
                permission
            }
        }
    }

    @Transactional
    fun createPermission(permission: Permission): Permission {
        val savedPermission = permissionRepository.save(permission)
        
        if (permission.departmentScope == DepartmentScope.SPECIFIC) {
            permissionDepartmentRepository.save(
                savedPermission.permissionDetailId,
                permission.specificDepartments
            )
        }
        
        return savedPermission
    }

    @Transactional
    fun updatePermission(permission: Permission): Permission {
        val updatedPermission = permissionRepository.update(permission)
        
        if (permission.departmentScope == DepartmentScope.SPECIFIC) {
            permissionDepartmentRepository.delete(permission.permissionDetailId)
            permissionDepartmentRepository.save(
                permission.permissionDetailId,
                permission.specificDepartments
            )
        }
        
        return updatedPermission
    }
}
```

## 4. テスト実装

### 4.1 PermissionServiceTest
ファイルパス: `src/test/kotlin/com/example/project/permission/application/service/PermissionServiceTest.kt`

```kotlin
package com.example.project.permission.application.service

import com.example.project.permission.domain.model.Permission
import com.example.project.permission.domain.model.vo.DepartmentScope
import com.example.project.permission.domain.repository.PermissionRepository
import com.example.project.permission.domain.repository.PermissionDepartmentRepository
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import java.time.LocalDateTime

class PermissionServiceTest : FunSpec({
    val permissionRepository = mockk<PermissionRepository>()
    val permissionDepartmentRepository = mockk<PermissionDepartmentRepository>()
    val permissionService = PermissionService(permissionRepository, permissionDepartmentRepository)

    test("findUserPermissions should return permissions with specific departments") {
        val now = LocalDateTime.now()
        val permission = Permission(
            permissionDetailId = 1L,
            permissionId = "PERM001",
            userId = "USER001",
            permissionType = "DOCUMENT",
            targetId = null,
            accessLevel = "READ",
            departmentScope = DepartmentScope.SPECIFIC,
            createdAt = now,
            updatedAt = now
        )

        every { permissionRepository.findByUserId("USER001") } returns listOf(permission)
        every { permissionDepartmentRepository.findByPermissionDetailId(1L) } returns 
            listOf("DEPT_A", "DEPT_B")

        val result = permissionService.findUserPermissions("USER001")

        result.size shouldBe 1
        result[0].specificDepartments shouldBe listOf("DEPT_A", "DEPT_B")
    }
})
```

### 4.2 PermissionRepositoryImplTest
ファイルパス: `src/test/kotlin/com/example/project/permission/infrastructure/repository/PermissionRepositoryImplTest.kt`

```kotlin
package com.example.project.permission.infrastructure.repository

import com.example.project.permission.domain.model.Permission
import com.example.project.permission.domain.model.vo.DepartmentScope
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional
import org.jooq.DSLContext
import java.time.LocalDateTime
import org.springframework.jdbc.core.JdbcTemplate

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class PermissionRepositoryImplTest(
    private val permissionRepository: PermissionRepository,
    private val dsl: DSLContext,
    private val jdbcTemplate: JdbcTemplate
) : FunSpec({

    beforeTest {
        // テストデータのクリーンアップ
        jdbcTemplate.execute("DELETE FROM PermissionDetail_Department")
        jdbcTemplate.execute("DELETE FROM PermissionDetail")
        
        // テストデータの投入
        jdbcTemplate.execute("""
            INSERT INTO PermissionDetail (permission_id, user_id, permission_type, target_id, access_level, department_scope)
            VALUES 
            ('PERM_1', 'TEST_USER_1', 'DOCUMENT', NULL, 'READ', 'ANY_DEPT'),
            ('PERM_2', 'TEST_USER_1', 'DOCUMENT', NULL, 'WRITE', 'OWN_DEPT'),
            ('PERM_3', 'TEST_USER_2', 'DOCUMENT', NULL, 'READ', 'SPECIFIC')
        """)
    }

    test("findByUserId should return permissions with ANY_DEPT scope") {
        val permissions = permissionRepository.findByUserId("TEST_USER_1")
        
        permissions.find { it.permissionId == "PERM_1" }?.let { permission ->
            permission.departmentScope shouldBe DepartmentScope.ANY_DEPT
            permission.accessLevel shouldBe "READ"
        }
    }

    test("findByUserId should return permissions with OWN_DEPT scope") {
        val permissions = permissionRepository.findByUserId("TEST_USER_1")
        
        permissions.find { it.permissionId == "PERM_2" }?.let { permission ->
            permission.departmentScope shouldBe DepartmentScope.OWN_DEPT
            permission.accessLevel shouldBe "WRITE"
        }
    }

    test("save should create new permission with SPECIFIC scope") {
        val now = LocalDateTime.now()
        val permission = Permission(
            permissionDetailId = 0L,
            permissionId = "PERM_4",
            userId = "TEST_USER_1",
            permissionType = "DOCUMENT",
            targetId = null,
            accessLevel = "READ",
            departmentScope = DepartmentScope.SPECIFIC,
            specificDepartments = listOf("DEPT_A", "DEPT_B"),
            createdAt = now,
            updatedAt = now
        )

        val savedPermission = permissionRepository.save(permission)
        savedPermission.permissionDetailId shouldNotBe 0L
        savedPermission.departmentScope shouldBe DepartmentScope.SPECIFIC
    }

    test("update should modify existing permission") {
        val permissions = permissionRepository.findByUserId("TEST_USER_1")
        val targetPermission = permissions.first()
        
        val updatedPermission = targetPermission.copy(
            accessLevel = "ADMIN"
        )
        
        val result = permissionRepository.update(updatedPermission)
        result.accessLevel shouldBe "ADMIN"
    }

    test("delete should remove permission") {
        val permissions = permissionRepository.findByUserId("TEST_USER_1")
        val targetPermission = permissions.first()
        
        permissionRepository.delete(targetPermission.permissionDetailId)
        
        val deletedPermission = permissionRepository.findById(targetPermission.permissionDetailId)
        deletedPermission shouldBe null
    }
})
```

### 4.3 PermissionDepartmentRepositoryImplTest
ファイルパス: `src/test/kotlin/com/example/project/permission/infrastructure/repository/PermissionDepartmentRepositoryImplTest.kt`

```kotlin
package com.example.project.permission.infrastructure.repository

import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional
import org.jooq.DSLContext
import org.springframework.jdbc.core.JdbcTemplate

@SpringBootTest
@ActiveProfiles("test")
@Transactional
class PermissionDepartmentRepositoryImplTest(
    private val permissionDepartmentRepository: PermissionDepartmentRepository,
    private val dsl: DSLContext,
    private val jdbcTemplate: JdbcTemplate
) : FunSpec({

    beforeTest {
        // テストデータのクリーンアップ
        jdbcTemplate.execute("DELETE FROM PermissionDetail_Department")
        
        // テストデータの投入
        jdbcTemplate.execute("""
            INSERT INTO PermissionDetail_Department (permission_detail_id, department_id)
            VALUES 
            ('PERM_3', 'DEPT_A'),
            ('PERM_3', 'DEPT_B')
        """)
    }

    test("findByPermissionDetailId should return all department IDs") {
        val departmentIds = permissionDepartmentRepository.findByPermissionDetailId(3L)
        
        departmentIds.size shouldBe 2
        departmentIds shouldBe listOf("DEPT_A", "DEPT_B")
    }

    test("save should create new department mappings") {
        val permissionDetailId = 4L
        val departmentIds = listOf("DEPT_C", "DEPT_D")
        
        permissionDepartmentRepository.save(permissionDetailId, departmentIds)
        
        val savedDepartmentIds = permissionDepartmentRepository.findByPermissionDetailId(permissionDetailId)
        savedDepartmentIds shouldBe departmentIds
    }

    test("delete should remove all department mappings") {
        permissionDepartmentRepository.delete(3L)
        
        val departmentIds = permissionDepartmentRepository.findByPermissionDetailId(3L)
        departmentIds shouldBe emptyList()
    }

    test("save should replace existing department mappings") {
        val permissionDetailId = 3L
        val newDepartmentIds = listOf("DEPT_X", "DEPT_Y")
        
        permissionDepartmentRepository.save(permissionDetailId, newDepartmentIds)
        
        val updatedDepartmentIds = permissionDepartmentRepository.findByPermissionDetailId(permissionDetailId)
        updatedDepartmentIds shouldBe newDepartmentIds
    }
})

## 5. テスト実行手順

1. テストデータベースの準備:
```bash
# MySQLコンテナの起動
docker-compose up -d

# テストデータベースの作成と初期化
./gradlew recreateAllDatabases
```

2. マイグレーションの実行:
```bash
./gradlew flywayMigrateAll
```

3. jOOQコードの生成:
```bash
./gradlew generateJooq
```

4. テストの実行:
```bash
./gradlew test
```

## 6. テストデータ

### 6.1 テストユーザーデータ
```sql
INSERT INTO User (user_id, department_id, username, email, password_hash, role_code)
VALUES 
('USER001', 'DEPT_A', 'test_user1', 'test1@example.com', 'dummy_hash', 'ROLE_USER'),
('USER002', 'DEPT_B', 'test_user2', 'test2@example.com', 'dummy_hash', 'ROLE_USER');
```

### 6.2 テスト部門データ
```sql
INSERT INTO Department (department_id, organization_id, name, department_code)
VALUES
('DEPT_A', 'ORG001', 'Department A', 'DEPT_A'),
('DEPT_B', 'ORG001', 'Department B', 'DEPT_B'),
('DEPT_C', 'ORG001', 'Department C', 'DEPT_C');
```

### 6.3 テスト権限データ
```sql
INSERT INTO PermissionDetail (
    permission_detail_id,
    permission_id,
    user_id,
    permission_type,
    target_id,
    access_level,
    department_scope
) VALUES
(1, 'PERM001', 'USER001', 'DOCUMENT', NULL, 'READ', 'ANY_DEPT'),
(2, 'PERM002', 'USER001', 'DOCUMENT', NULL, 'WRITE', 'OWN_DEPT'),
(3, 'PERM003', 'USER001', 'DOCUMENT', NULL, 'READ', 'SPECIFIC');

INSERT INTO PermissionDetail_Department (permission_detail_id, department_id)
VALUES
(3, 'DEPT_A'),
(3, 'DEPT_B');
```

## 7. 注意点

1. データベース関連
   - テストデータベースは本番とは別のデータベースを使用
   - 各機能ごとに独立したデータベースを使用
   - テストデータベースのポートは3307を使用
   - 文字コードはutf8mb4を使用

2. テスト実行
   - テストは`@Transactional`アノテーションにより、各テストケース後にロールバック
   - テストデータは`beforeTest`ブロックで毎回クリーンアップして再投入
   - モックを使用する場合は、`mockk`ライブラリを使用
   - テストカバレッジは80%以上を目標

3. jOOQ
   - コード生成は`generateJooq`タスクで実行
   - マイグレーション後に必ずコード生成を実行
   - 生成されたコードは`build/generated-src/jooq/main`に配置

4. Flyway
   - マイグレーションは`flywayMigrateAll`タスクで実行
   - 各データベースごとに独立したマイグレーションスクリプトを管理
   - マイグレーション実行前に`recreateAllDatabases`タスクを実行

5. セキュリティ
   - 本番環境の接続情報は環境変数で管理
   - テスト環境の接続情報は`gradle.properties`で管理
   - パスワードなどの機密情報はバージョン管理対象外
