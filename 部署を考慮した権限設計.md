以下では、**既存のテーブル定義**と、先ほどの「**department_scope** による任意部門・特定部門への権限付与」のアイデアを**統合**した形でご提案します。  
**「PermissionDetailテーブルの構造を少し拡張し、department_scope で部門スコープを管理する」** という流れです。

---

# 1. **既存テーブル定義の課題と追加カラム**

ご提示いただいた `PermissionDetail` テーブルは以下のようになっています:

```sql
CREATE TABLE PermissionDetail (
    permission_id    VARCHAR(36)   NOT NULL,
    user_id          VARCHAR(36)   NOT NULL,
    permission_type  VARCHAR(50)   NOT NULL,
    target_id        VARCHAR(36)   NULL,
    access_level     VARCHAR(50)   NOT NULL,
    created_at       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT PK_PermissionDetail PRIMARY KEY (permission_id),
    CONSTRAINT FK_PermissionDetail_User FOREIGN KEY (user_id) REFERENCES User(user_id)
);
```

ここに、**「どの部門に対してこの権限が有効なのか」**を示す**`department_scope`** カラムを追加することで、  
**「任意の部門に対して」「自分の所属部門(や下位部門)に対して」「特定部門だけ」「複数部門だけ」**などを柔軟に表現できるようになります。

---

## 1.1. **テーブル定義の改訂案**

```sql
CREATE TABLE PermissionDetail (
    permission_id      VARCHAR(36)  NOT NULL,
    user_id            VARCHAR(36)  NOT NULL,
    permission_type    VARCHAR(50)  NOT NULL,
    target_id          VARCHAR(36)  NULL,
    access_level       VARCHAR(50)  NOT NULL,
    department_scope   VARCHAR(50)  NOT NULL,  -- ★ 追加 ★

    created_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    CONSTRAINT PK_PermissionDetail PRIMARY KEY (permission_id),
    CONSTRAINT FK_PermissionDetail_User FOREIGN KEY (user_id) REFERENCES User(user_id)
);
```

### カラム説明

| カラム名         | 用途                                                                                           |
|:-----------------|:-----------------------------------------------------------------------------------------------|
| `permission_id`  | PermissionDetail の主キー (UUID想定など)                                                       |
| `user_id`        | この権限が割り当てられているユーザ（あるいは「ユーザ」を仮想的に「ロールユーザ」にする場合も） |
| `permission_type`| 例: `"ASSET"`, `"DOCUMENT"`, `"AUDIT"` など **ドメインを示す**                                  |
| `target_id`      | どの資産や文書、特定のIDに対する権限か。<br>NULLなら「ドメイン全体」を指すなど運用可能           |
| `access_level`   | 例: `"READ_ONLY"`, `"READ_WRITE"`, `"EXECUTE"`, `"APPROVE"` など操作レベル                       |
| `department_scope`| 例: `"ANY_DEPT"`, `"OWN_DEPT"`, `"DEPT_ABC"`, `"MULTI:DEPT_SEC,DEPT_AUDIT"` など               |
| `created_at`     | レコード作成日時                                                                               |
| `updated_at`     | レコード更新日時                                                                               |

---

# 2. **department_scope** の使い方

下記のような文字列ルールを**運用ドキュメントで定義**しておき、  
**アプリケーション側**で `department_scope` を判定するロジックを書きます。

- `"ANY_DEPT"` : 全社（任意の部門）  
- `"OWN_DEPT"` : ログインユーザの所属部門（＋下位部門）だけ  
- `"DEPT_XXX"` : 特定の1部門のみ  
- `"MULTI:DEPT_A,DEPT_B"` : 複数部門  

### 2.1. **サンプルデータ**

例えば、**ユーザID=U001** に対し、次のような権限を付与するイメージです（`permission_id` は便宜的に連番例を記載）:

| permission_id | user_id | permission_type | target_id | access_level | department_scope                 | 補足                                                                                  |
|:-------------:|:-------:|:---------------:|:---------:|:------------:|:---------------------------------:|:--------------------------------------------------------------------------------------|
| 1001          | U001    | ASSET           | NULL      | READ_WRITE   | ANY_DEPT                         | どの部門が所有する資産(ASSET)でも読み書き可能 (例: サーバ、モバイル端末 etc.)          |
| 1002          | U001    | DOCUMENT        | NULL      | READ_ONLY    | OWN_DEPT                         | 自分の部門(や下位部門)にある文書のみ参照可                                            |
| 1003          | U001    | DOCUMENT        | NULL      | APPROVE      | ANY_DEPT                         | 全社どの部門の文書でも承認操作可能                                                   |
| 1004          | U001    | AUDIT           | NULL      | EXECUTE      | DEPT_AUDIT                       | `"DEPT_AUDIT"` 部門に属する対象(プロジェクトや資産)だけ監査実行可(部門の範囲を限定)   |
| 1005          | U001    | DOCUMENT        | NULL      | READ_WRITE   | DEPT_SEC                         | `"DEPT_SEC"` 部門の手順書やガイドライン等だけ編集可                                   |
| 1006          | U001    | DOCUMENT        | NULL      | READ_ONLY    | MULTI:DEPT_ABC,DEPT_DEF          | 部門ABC, DEFだけ参照可                                                                |

> - `target_id` を NULL にしているのは、「このドメイン全体」への権限とみなすためです。  
>   もし特定の文書IDや特定の資産IDだけに権限を付与したいなら `target_id` にIDをセットします。

---

# 3. **アクセス判定の擬似ロジック**

### 3.1. 概要

1. **ユーザ(user_id)** から `PermissionDetail` を全件取得  
2. 該当ドメイン(`permission_type` = `"DOCUMENT"` など) ＆ 操作(`access_level`= `"APPROVE"` など) が一致する行を探す  
3. さらに **`department_scope`** が対象部門に合致するか判定  
   - **ANY_DEPT** → 常にOK  
   - **OWN_DEPT** → `user.department_id` と `targetDepartmentId` が同じ or 下位の場合OK  
   - **DEPT_XXX** → `targetDepartmentId == "DEPT_XXX"` ならOK  
   - **MULTI:DEPT_ABC,DEPT_DEF** → `targetDepartmentId` が `["DEPT_ABC","DEPT_DEF"]` のいずれかならOK  

### 3.2. 擬似コード例

```pseudo
function canAccess(user, targetDomain, targetDeptId, requestedAccess):
    // 1) ユーザのPermissionDetail一覧を取得
    permissionDetails = findPermissionDetailByUser(user.user_id)

    // 2) マッチング判定
    for detail in permissionDetails:
        if detail.permission_type == targetDomain
           and detail.access_level == requestedAccess
        then
            // 3) department_scope 判定
            if matchDepartmentScope(detail.department_scope, user.department_id, targetDeptId) then
                return true

    return false


function matchDepartmentScope(scope, userDeptId, targetDeptId):
    switch scope:
        case "ANY_DEPT":
            return true

        case "OWN_DEPT":
            return isSameOrSubDept(userDeptId, targetDeptId)

        default:
            if scope startsWith "MULTI:":
                allowedList = scope.replace("MULTI:","").split(",")
                return (targetDeptId in allowedList)
            else:
                // scope == "DEPT_ABC" 等の1部門
                return (scope == targetDeptId)
```

> **isSameOrSubDept** は、組織階層を辿って「userDeptId が targetDeptId の上位にあたるか」などをチェックするユーティリティメソッドを想定。  
> 組織(Department)に親子関係がある場合、Recursiveに親を辿る処理などを実装してください。

---

# 4. **今の内容（department_scope方式）と「role_code」やM_CODE活用の統合**

現在のスキーマでは、**Userテーブルに `role_code`** が存在し、`PermissionDetail` は **`user_id`** 直付けになっています。  
運用上、**1ユーザに1ロール**であれば、以下のいずれかのパターンが考えられます。

1. **パターンA:「ユーザ単位」で PermissionDetail を管理**  
   - `PermissionDetail.user_id` に具体的なユーザIDをセットし、個別権限を直接付与する。  
   - 「role_code」は画面表示や大まかな区分として使う。  
   - 細かい「department_scope」や「target_id」レベルの制御はすべて PermissionDetail で運用。

2. **パターンB: 「ロールユーザ」用のダミーUserを作り、実質「ロール単位」で PermissionDetail を管理**  
   - 例えば `User(user_id="ROLE_ADMIN")` のように**ロール名をuser_idとして**登録する(実ユーザでなく「ロールの疑似ユーザ」)。  
   - 各実ユーザが「role_code=ADMIN」なら、この「ROLE_ADMIN」の PermissionDetail を参照して権限を判定する。  
     - （アプリ側で: `if (user.role_code=="ADMIN") => PermissionDetail参照: user_id="ROLE_ADMIN"`)  
   - こうすると、「同じロールのユーザ」は**一括で同じ PermissionDetail**を共有可能。ロールベースで department_scope を設定できる。

3. **パターンC: M_CODE('USER_ROLE') + 中間テーブル**  
   - もし「ロール (M_CODE) : PermissionDetail = 1 : n」の関係が必要なら、  
     - (a) `PermissionDetail.role_code` を追加し、**ロールコード**をキーとして権限行を作る  
     - (b) `role_code` でログインユーザを判定し、そのロールに紐づく権限リストを取得  
   - あるいは**中間テーブル** ( `RolePermission(role_code, permission_detail_id)` ) を用意し、**ユーザ → role_code → RolePermission → PermissionDetail** の流れで参照する。

> いずれにせよ、**「department_scope」カラムで部門スコープを表現**しながら、  
> **ユーザ or ロール**のどちらに権限を紐づけるかはシステム設計方針で決まります。

---

# 5. **サンプルデータ** (permission_detail_id=81～120)

先ほどのサンプル（81〜120の40件）を、**今回のテーブル設計**に合わせて書き換えるときは、  
以下の点を調整する必要があります:

- **`permission_id`**: 主キー (UUIDや連番)  
- **`user_id`**: 誰に紐づけるか → 便宜上 `U001` とか共通にしておく  
- **`permission_type`, `access_level`, `department_scope`** をそれぞれ割り当て  
- **`target_id`** は NULL にして、ドメイン全体に適用させるか、または何らかのIDを示す。  

以下、例として **81〜90行目** だけ示します（全40件分書き換えも可能ですが、長くなるため一部抜粋）。  
`department_scope` には「ANY_DEPT」や「OWN_DEPT」など、または適宜設定をどうぞ。

```markdown
| permission_id | user_id | permission_type | target_id | access_level | department_scope | 補足説明                                                   |
|--------------:|:-------:|:---------------:|:---------:|:-----------:|:----------------:|:-----------------------------------------------------------|
| 81            | U001    | QUALITY         | NULL      | READ_WRITE  | ANY_DEPT         | 品質マニュアルやQMS関連文書を参照・編集可                  |
| 82            | U001    | QUALITY         | NULL      | EXECUTE     | OWN_DEPT         | QMS内部監査を実施可（自部門のみ）                          |
| 83            | U001    | QUALITY         | NULL      | READ_WRITE  | DEPT_QMS         | QMSの是正/予防措置(CAPA)登録・更新可(特定部門限定)         |
| 84            | U001    | SAFETY          | NULL      | CREATE      | ANY_DEPT         | 安全管理上のインシデント(ヒヤリハット)を全社で起票可       |
| 85            | U001    | SAFETY          | NULL      | READ_ONLY   | MULTI:DEPT_A,DEPT_B | ハザード台帳を 部門A or 部門B の場合のみ参照可能       |
| 86            | U001    | SAFETY          | NULL      | READ_WRITE  | OWN_DEPT         | 安全対策(防護具等)を自部署だけ登録/更新可                  |
| 87            | U001    | ENVIRONMENT     | NULL      | READ_WRITE  | ANY_DEPT         | EMS文書を参照・編集可(全社横断)                            |
| 88            | U001    | ENVIRONMENT     | NULL      | EXECUTE     | DEPT_ENV         | 廃棄物管理処理を実行可(特定部門ENVのみ)                    |
| 89            | U001    | ENVIRONMENT     | NULL      | READ_ONLY   | OWN_DEPT         | 環境規制遵守ログを自部署だけ参照可                          |
| 90            | U001    | SOCIAL          | NULL      | APPROVE     | ANY_DEPT         | CSRポリシーを全社対象で承認可                               |
```

> - 他の行(91〜120)も、`permission_type` を `"SECURITY"`, `"CLOUD"`, `"DATA"`, `"COMPLIANCE"`, `"GOVERNANCE"`, `"OPEN_SOURCE"`, `"METRICS"`, `"SERVICE_DESK"` などに割り当て、  
>   `access_level` を `"MONITOR"`, `"EXECUTE"`, `"READ_WRITE"`, `"REVIEW"`, `"ESCALATE"`, etc. として設定すれば、同じ要領で運用できます。

---

# 6. **まとめ**

1. **PermissionDetailテーブルに `department_scope` を追加**することで、  
   「任意の部門」/「自部門」/「特定部門」/「複数部門」などのスコープ制御を文字列で表現可能。

2. **アクセス判定**は  
   1) ユーザに紐づく PermissionDetail を取得  
   2) `permission_type` / `access_level` が要求と合致するものを探す  
   3) `department_scope` 判定で部門が合致するかチェック  
   というステップ。

3. **既存の `role_code`** をどう活かすかは運用次第。  
   - 個人に直接権限を付与する (user_id 直紐づけ) パターン  
   - ロール用ユーザ(ダミー)を作成して共有 (RBAC) パターン  
   - 中間テーブルなどで `role_code` → `PermissionDetail` をマッピングするパターン  
   など複数あります。

4. **サンプルデータ(81〜120)** も、  
   - `permission_type` (QUALITY, SAFETY, ENVIRONMENT, etc.)  
   - `access_level` (READ_WRITE, EXECUTE, etc.)  
   - `department_scope` (ANY_DEPT, OWN_DEPT, DEPT_XXX, MULTI:...)  
   を設定し直せば、同様の「QMS, EMS, CSR, SECURITY, CLOUD, DATA…」など多領域に対応可能。  

これにより、**大規模企業での複雑な「部門単位の権限制御」**や**多様なドメイン×操作レベル**を**単一テーブル＆文字列ルール**で運用できるようになります。  

- **JOIN禁止・キャッシュ参照**の方針を組み合わせる場合は、あらかじめPermissionDetailをアプリ起動時に読み込み、メモリ上で検索するアーキテクチャを採ることも可能です。  
- 「role_code と department_scope」をさらに組み合わせたい場合は**M_CODE** や **中間テーブル**を検討し、**権限の付与・更新**をより集約的に行えるようにするのが推奨です。