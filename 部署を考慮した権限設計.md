以下では、**「department_scope」カラムによるシンプルなスコープ管理**と、**「PermissionDetail_Department」中間テーブルによる複数部門への正規化対応**を統合した形でご提案します。  
従来の `"MULTI:DEPT_A,DEPT_B"` のような文字列区切りによるアンチパターンを避けつつ、  
**ANY_DEPT / OWN_DEPT / DEPT_Xxx** といった単一スコープも同一テーブルで扱えるようにする設計です。

---

## 1. **既存PermissionDetailテーブルへの拡張**

### 1.1. 既存テーブルの問題点

従来のテーブル定義では下記の通りでした。

```sql
CREATE TABLE PermissionDetail (
    permission_id    VARCHAR(36)   NOT NULL,
    user_id          VARCHAR(36)   NOT NULL,
    permission_type  VARCHAR(50)   NOT NULL,
    target_id        VARCHAR(36)   NULL,
    access_level     VARCHAR(50)   NOT NULL,
    created_at       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at       TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT PK_PermissionDetail PRIMARY KEY (permission_id),
    CONSTRAINT FK_PermissionDetail_User FOREIGN KEY (user_id) REFERENCES User(user_id)
);
```

ここに、「どの部門範囲で権限が有効か」を示すために **`department_scope`** を追加して、  
従来提案していた `"ANY_DEPT"`, `"OWN_DEPT"`, `"DEPT_XXX"`, `"MULTI:DEPT_A,DEPT_B"` などで柔軟に管理したい、という要望がありました。

しかし、**文字列で `MULTI:DEPT_A,DEPT_B` のように区切り管理**するのは、  
**正規化の観点からアンチパターン**になりがちです（検索・JOINが困難、カンマ区切りのパースが煩雑など）。

### 1.2. 拡張の基本方針

1. **単一スコープ**（ANY_DEPT / OWN_DEPT / 特定1部門）は `department_scope` カラムで管理。  
2. **複数部門**（いわゆる `MULTI:…` のようなケース）は、中間テーブル（PermissionDetail_Department）で正規化して管理。

---

## 2. **改訂後のテーブル定義案**

### 2.1. PermissionDetailテーブル（改訂版）

```sql
CREATE TABLE PermissionDetail (
    permission_detail_id BIGINT AUTO_INCREMENT NOT NULL,
    permission_id        VARCHAR(36)   NOT NULL,   -- 従来の主キー(外部からUUID等を入れるならこちらをPKにしても可)
    user_id              VARCHAR(36)   NOT NULL,
    permission_type      VARCHAR(50)   NOT NULL,   -- "ASSET", "DOCUMENT", "AUDIT" など
    target_id            VARCHAR(36)   NULL,       -- 例: 特定文書IDや資産IDへの権限。NULLならドメイン全体。
    access_level         VARCHAR(50)   NOT NULL,   -- "READ_ONLY", "READ_WRITE", "APPROVE", "EXECUTE" など
    department_scope     VARCHAR(50)   NOT NULL,   -- "ANY_DEPT", "OWN_DEPT", "SPECIFIC" など

    created_at           TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at           TIMESTAMP     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    -- 主キーは AUTO_INCREMENT の permission_detail_id を使用する例
    CONSTRAINT PK_PermissionDetail PRIMARY KEY (permission_detail_id),

    -- あるいは下記を別途設定してもOK (複合ユニークなど)
    -- UNIQUE (permission_id),

    CONSTRAINT FK_PermissionDetail_User 
        FOREIGN KEY (user_id) REFERENCES User(user_id)
);
```

#### ポイント

1. **`department_scope` に文字列を設定**  
   - `"ANY_DEPT"` → 全社対象  
   - `"OWN_DEPT"` → 自部門や下位部門のみ  
   - `"SPECIFIC"` → 対象部門を PermissionDetail_Department で管理するケース  
2. **`permission_id`** は外部システムや別画面で管理するIDならそのまま利用可。  
   - 実運用でユニークにできるなら `permission_id` をPKにしてもよい。  
   - AUTO_INCREMENTを使いたい場合は上記のように `permission_detail_id`（連番）をPKにし、`permission_id` は外部キー相当とする形もあり。  

> 設計上はどちらでも可ですが、**外部連携IDとして `permission_id`**（UUIDなど）を使うパターンと、**内部テーブルのAUTO_INCREMENT**をPKにするパターンがあります。

---

### 2.2. PermissionDetail_Departmentテーブル

**複数部門を紐づけたい**場合、`PermissionDetail.department_scope` を `"SPECIFIC"` としておき、  
その詳細は中間テーブルにレコードを登録します。

```sql
CREATE TABLE PermissionDetail_Department (
    permission_detail_id BIGINT NOT NULL,
    department_id        VARCHAR(36) NOT NULL,

    created_at           TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at           TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    CONSTRAINT PK_PermissionDetail_Department 
        PRIMARY KEY (permission_detail_id, department_id),

    CONSTRAINT FK_PermissionDetail_Department
        FOREIGN KEY (permission_detail_id) 
        REFERENCES PermissionDetail(permission_detail_id),

    CONSTRAINT FK_PermissionDetail_DepartmentDept
        FOREIGN KEY (department_id) 
        REFERENCES Department(department_id)
);
```

#### ポイント

- `PermissionDetail.department_scope = 'SPECIFIC'` である行に対して、  
  **対応する複数部門**（1行につき1部門）を **PermissionDetail_Department** へ INSERT していく。  
- これにより、**部門IDのリスト**を正規化でき、カンマ区切りなどが不要。  
- 検索時に `JOIN`（または `IN` クエリ）で複数部門を管理できる。

---

## 3. 運用例

### 3.1. department_scope の値

1. **"ANY_DEPT"**  
   - 全社で有効 → 中間テーブルは不要
2. **"OWN_DEPT"**  
   - ログインユーザの所属部門（および下位部門） → 中間テーブルは不要
4. **"SPECIFIC"**  
   - 対象部門 → PermissionDetail_Department に個別行を登録

### 3.2. アクセス判定のフロー

以下、擬似コード例です。

```pseudo
function canAccess(user, targetDomain, targetDeptId, requestedAccess):
    // 1) 該当ユーザのPermissionDetail一覧を取得
    permissionDetails = findPermissionDetailByUser(user.user_id)

    // 2) マッチング判定
    for detail in permissionDetails:
        if detail.permission_type == targetDomain
           and detail.access_level == requestedAccess
        then
            // department_scope をチェック
            switch detail.department_scope:
                case "ANY_DEPT":
                    return true

                case "OWN_DEPT":
                    if isSameOrSubDept(user.department_id, targetDeptId):
                        return true

                default:
                    // "DEPT_ABC" のように特定1部門
                    if detail.department_scope startsWith "DEPT_":
                        if targetDeptId == detail.department_scope:
                            return true
                    else if detail.department_scope == "SPECIFIC":
                        // 中間テーブルから対象部門の一覧を取得
                        allowedDeptIds = findDepartmentsByPermissionDetailId(detail.permission_detail_id)
                        if targetDeptId in allowedDeptIds:
                            return true
                    // それ以外は不一致

    return false
```

> ※ `isSameOrSubDept(user.department_id, targetDeptId)` は、組織の階層構造（Department.parent_id など）を再帰的にチェックして、  
>   「ユーザが所属している部門の下位に targetDeptId が含まれるかどうか」を判定するユーティリティです。

---

## 4. サンプルデータ例

### 4.1. PermissionDetail の例

| permission_detail_id | permission_id | user_id | permission_type | target_id | access_level | department_scope | 補足                                                                                  |
|---------------------:|--------------:|:-------:|:---------------:|:---------:|:-----------:|:----------------:|:--------------------------------------------------------------------------------------|
| 1                    | 'PERM081'     | U001    | QUALITY         | NULL      | READ_WRITE  | ANY_DEPT         | QMS関連の文書などを全社横断で読み書き可能                                            |
| 2                    | 'PERM082'     | U001    | QUALITY         | NULL      | EXECUTE     | OWN_DEPT         | 自部門のQMS内部監査などを実行可                                                      |
| 3                    | 'PERM083'     | U001    | QUALITY         | NULL      | READ_WRITE  | DEPT_QMS         | 「DEPT_QMS」という単一部門のみ読み書き可                                             |
| 4                    | 'PERM084'     | U001    | SAFETY          | NULL      | CREATE      | ANY_DEPT         | 安全管理インシデントを全社で起票可                                                   |
| 5                    | 'PERM085'     | U001    | SAFETY          | NULL      | READ_ONLY   | SPECIFIC         | 複数部門（後述の中間テーブルにて管理）だけ参照可                                     |
| 6                    | 'PERM086'     | U001    | SAFETY          | NULL      | READ_WRITE  | OWN_DEPT         | 自部署だけ安全対策の登録/更新可                                                     |
| 7                    | 'PERM087'     | U001    | ENVIRONMENT     | NULL      | READ_WRITE  | ANY_DEPT         | 全社のEMS文書を編集可                                                                |
| 8                    | 'PERM088'     | U001    | ENVIRONMENT     | NULL      | EXECUTE     | DEPT_ENV         | 「DEPT_ENV」という単一部門限定で廃棄物管理実行可                                     |
| 9                    | 'PERM089'     | U001    | ENVIRONMENT     | NULL      | READ_ONLY   | OWN_DEPT         | 自部門だけ環境規制遵守ログを参照可                                                  |
| 10                   | 'PERM090'     | U001    | SOCIAL          | NULL      | APPROVE     | ANY_DEPT         | CSRポリシーを全社対象で承認可                                                       |

### 4.2. PermissionDetail_Department の例

- 上記の行 **5 ('PERM085')** は `department_scope='SPECIFIC'` となっているため、  
  **複数部門**が対象になる場合は、下記のように中間テーブルへINSERTします。

```sql
INSERT INTO PermissionDetail_Department (permission_detail_id, department_id)
VALUES
(5, 'DEPT_A'),    -- 部門A
(5, 'DEPT_B');    -- 部門B
```

こうすると、**(permission_detail_id=5)** の権限は部門Aと部門Bにだけ有効、  
ユーザがアクセスする際に `targetDeptId` が "DEPT_A" か "DEPT_B" のときにのみ成立、という形で運用できます。

---

## 5. まとめ

1. **department_scopeカラム + 中間テーブル**のハイブリッド方式  
   - **"ANY_DEPT" / "OWN_DEPT" / "DEPT_XXX"** のような単一スコープは department_scope に文字列で直接保持。  
   - **複数部門**（"SPECIFIC"）の場合は、**PermissionDetail_Department** に部門IDを正規化して複数行登録し、  
     文字列のカンマ区切りを回避する。

2. **ACCESS判定の実装**  
   - department_scope が **ANY_DEPT** → 常に通す  
   - department_scope が **OWN_DEPT** → `isSameOrSubDept(userDeptId, targetDeptId)`  
   - department_scope が **"DEPT_XXX"** → 直接一致を確認  
   - department_scope が **"SPECIFIC"** → 中間テーブルをJOINまたは検索し、当該 `targetDeptId` が含まれるかどうかを判定

3. **ロールとの組み合わせ**  
   - ユーザ個別に権限を割り当てる場合は `user_id` をそのまま使用。  
   - ロールベースにしたい場合はダミーユーザID("ROLE_ADMIN"など)を作るか、別途 `RolePermission(role_code, permission_detail_id)` の中間テーブルを追加。  
   - いずれにせよ、**複雑な部門スコープ**を柔軟に設定できる仕組みを確立できる。

4. **サンプルデータ**  
   - 既存の (81〜120) のような例を全て対応させるには、単一部門の場合は直接 `department_scope="DEPT_XYZ"`、  
     複数部門の場合は `department_scope="SPECIFIC"` とし、**PermissionDetail_Department** に部門IDを必要数だけINSERTする。  

このように改訂することで、**"MULTI:DEPT_A,DEPT_B"** のような文字列パース不要で正規化された複数部門管理が可能となり、  
大規模かつ複雑な部門構造を扱う場合でも**柔軟に権限を拡張**していける設計が完成します。