以下では、**Assetテーブル**から「機密性・完全性・可用性・個人情報フラグ」等の属性を切り出し、  
**AssetAttribute** などの専用テーブルを用いて管理する例を示します。

---

# **1. テーブル構造の変更イメージ**

## 1-1. **従来**の `Asset` テーブル (変更前)

```sql
CREATE TABLE Asset (
    asset_id               VARCHAR(36) NOT NULL,
    name                   VARCHAR(100) NOT NULL,
    asset_type_code        VARCHAR(50)  NOT NULL,  -- ex: "SERVER", etc.
    confidentiality_level  INT         NOT NULL,
    integrity_level        INT         NOT NULL,
    availability_level     INT         NOT NULL,
    contains_personal_data BOOLEAN     NOT NULL,
    ...
    CONSTRAINT PK_Asset PRIMARY KEY (asset_id)
);
```

## 1-2. **改訂後**の `Asset` + `AssetAttribute` テーブル (変更後)

### **Asset** テーブル

```sql
CREATE TABLE Asset (
    asset_id         VARCHAR(36) NOT NULL,
    name             VARCHAR(100) NOT NULL,
    asset_type_code  VARCHAR(50)  NOT NULL,  -- ex: "SERVER", "APPLICATION" etc.

    -- その他、純粋にAssetの基本情報のみ残す
    -- (location, vendor, serial_number, etc. 必要に応じて追加)

    created_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    CONSTRAINT PK_Asset PRIMARY KEY (asset_id)
);
```

### **AssetAttribute** テーブル

```sql
CREATE TABLE AssetAttribute (
    asset_attribute_id     VARCHAR(36) NOT NULL,
    asset_id               VARCHAR(36) NOT NULL,

    confidentiality_level  INT         NOT NULL,  -- 0=低,1=中,2=高 等
    integrity_level        INT         NOT NULL,
    availability_level     INT         NOT NULL,
    contains_personal_data BOOLEAN     NOT NULL,

    -- 例: 他にもビジネス重要度(business_criticality)やネットワークゾーン(network_zone)等を追加
    -- business_criticality INT         NOT NULL,
    -- network_zone         VARCHAR(50) NULL,

    created_at             TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at             TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    CONSTRAINT PK_AssetAttribute PRIMARY KEY (asset_attribute_id),
    CONSTRAINT FK_AssetAttribute_Asset 
        FOREIGN KEY (asset_id) REFERENCES Asset(asset_id)
);
```

- `Asset` は**純粋に資産の基本情報**のみ保持し、**機密性(C)、完全性(I)、可用性(A)** や **個人情報フラグ**などの「セキュリティ上のリスク評価に使う属性」は、`AssetAttribute` に切り出します。  
- 1:1 関係で運用する場合は、**同じ `asset_id` をPKとして使う方法**もありますが、  
  上記のように `asset_attribute_id` (PK) と `asset_id` (FK) を分けておくと、将来的に **1:many** に拡張しやすくなります（例: バージョンや履歴管理を行いたいケースなど）。

---

# **2. サンプルINSERT例**

```sql
-- 1) 資産そのものの基本情報
INSERT INTO Asset (
    asset_id, 
    name, 
    asset_type_code
) VALUES
('AS001', '顧客情報DBサーバ', 'SERVER'),
('AS002', 'ファイルサーバ(一般文書)', 'SERVER');


-- 2) 資産のセキュリティ属性 (C/I/Aレベル等)
INSERT INTO AssetAttribute (
    asset_attribute_id,
    asset_id,
    confidentiality_level,
    integrity_level,
    availability_level,
    contains_personal_data
) VALUES
('AA001','AS001',2,1,2,true),
('AA002','AS002',1,1,1,false);
```

- 例では、`AS001` (顧客情報DBサーバ) のCレベル=2(高), Aレベル=2(高), 個人情報あり(`true`)、  
  `AS002` はC/I/A=1(中or低)で個人情報なし。
- ルールベースのリスク推論では、**`AssetAttribute`** の情報を参照して `RiskTemplate` などの条件を満たすか判定します。

---

# **3. リスク導出ロジックの変更点**

先に提示した「資産属性をもとにリスクを自動導出するロジック」では、  
**`Asset`から直接 C/I/A/個人情報フラグを取得**していましたが、  
**`AssetAttribute` に分離**したため、下記のように読み取ります。

```pseudo
function deriveRisksForAsset(assetId):
    // 1. assetを取得
    asset = getAssetById(assetId)
    // 2. assetAttributeを取得 (1:1想定で1件取得)
    attr = getAssetAttributeByAssetId(assetId)
      // attr.confidentiality_level = 2
      // attr.contains_personal_data = true
      // ...

    // 3. RiskTemplateを全件取得
    riskTemplates = getAllRiskTemplates()

    derivedRisks = []

    for each template in riskTemplates:
        // 4. template.condition_expressionを解析して評価
        //    例: "(confidentiality_level >= 2 OR contains_personal_data == true)"
        if evaluateExpression(template.condition_expression, attr):
            // 5. リスクを作成しDBにINSERT
            newRisk = {
                risk_id: generateUUID(),
                project_id: <some project>,
                asset_id: assetId,
                risk_name: template.risk_name,
                ...
            }
            insertRisk(newRisk)
            derivedRisks.add(newRisk)

    return derivedRisks
```

- ここでは `attr = getAssetAttributeByAssetId(assetId)` を使って、**C/I/A/個人情報**などの値を取りにいく点が変更されています。
- そのほかのロジックは基本的に同じです。

---

# **4. 追加検討: 属性の履歴管理 / バージョン管理**

- もし**時系列でC/I/Aなどが変化**する（リスク再評価など）場合は、`AssetAttribute` を**履歴テーブル**として1:nにする手法もあります。  
  - 例: `asset_attribute_id` ごとに「いつの日時でC/I/Aがどうだったか」を記録。  
  - `valid_from`, `valid_to` カラムを追加して運用する、など。
- ただし最初は1:1の単純形で問題ないことが多いので、将来の要件を見据えて設計を検討できます。

---

## **まとめ**

- **Asset** に「機密性 / 可用性 / 個人情報」などのセキュリティ評価カラムを持たせるのではなく、**`AssetAttribute`** テーブルに切り出すことで、  
  - **責務の分離**（Assetはあくまで資産の基本的な情報管理、セキュリティ評価は別テーブル）  
  - **将来的な履歴管理・多様な属性追加の柔軟性**  
- リスク推論や管理策の自動導出ロジック自体はほぼ同様で、**属性を取得する先が`AssetAttribute`になった**点だけ変わります。

以上が、**資産属性を別テーブル化**したDB定義とサンプルINSERT例、およびリスク推論の留意点です。